# Bloom Filter

Bloom filter (фильтр Блума) — это вероятностная структура данных, предназначенная для проверки принадлежности элемента
к множеству. Фильтр может давать ложноположительные срабатывания (утверждать, что элемент присутствует, когда его нет),
но никогда не даёт ложноотрицательных ответов.

Основным преимуществом по сравнению с хэш-таблицами является компактный размер (сравнительный пример см. ниже).

## Особенности реализации

* Возможность задать хэш-функцию
* Поддержка режима конкуренции - параллельные чтение и запись
* Отсутствие блокировок (использование только atomic операций)
* Использование SIMD-операций где применимо
* Поддержка Counting Bloom Filter (абстракция хранилища)

## Математическое обоснование

### Расчет оптимальных параметров

Размер $m$ битового массива и $k$ вычисляется на основе заданных параметров:
- $N$ — предполагаемое максимальное количество элементов
- $FPP$ — желаемая вероятность ложноположительного срабатывания

Оптимальный размер битового массива $m$ вычисляется как:

$$
m = -\frac{N \cdot \ln(FPP)}{(\ln 2)^2}
$$

Оптимальное количество хэш-функций $k$:

$$
k = \frac{m}{N} \ln 2
$$

### Пример расчета

Для $N = 1,000,000$ элементов и $FPP = 0.01$ (1%):

1. Рассчитаем $m$:
   
$$
m = -\frac{1,000,000 \cdot \ln(0.01)}{(\ln 2)^2} \approx -\frac{1,000,000 \cdot (-4.605)}{0.4805} \approx 9,583,000 \text{ бит} \approx 1.14 \text{ MB}
$$

2. Рассчитаем $k$:

$$
k = \frac{9,583,000}{1,000,000} \cdot 0.693 \approx 6.64 \approx 7 \text{ хэш-функций}
$$

Если взять за референс хэш-таблицу, хранящую только 8-байтными ключи, то размер только ключей будет ~7.63 МБ, что примерно
в 7 раз меньше. Реальный размер будет ещё больше за счёт дополнтельных структур данных (бакеты) и коэффициента заполнения (+30-50%).

## Использование

```go
package main

import (
    "github.com/koykov/pbtk/amq/bloom_filter"
    "github.com/koykov/pbtk/metrics/prometheus"
    "github.com/koykov/hash/xxhash"
)

const (
    N = 1000
    FPP = 0.01
)

func main() {
    hasher := xxhash.Hasher64[[]byte]{} // hash function
    config := bloom.NewConfig[string](N, FPP, hasher).
        WithConcurrency(). // switch to race protected bit array (atomic based)
        WithMetricsWriter(prometheus.NewAMQ("example_filter")) // cover with metrics
    // config.WithCBF() // switch to counting bloom filter
    f, err := bloom.NewFilter[string](config)
    _ = err
    _ = f.Set("foobar")
    print(f.Contains("foobar")) // true
    print(f.Contains("qwerty")) // false
}
```

## Области применения

1. **Кэширование**: Быстрая проверка наличия данных в кэше перед дорогостоящими операциями
2. **Базы данных**: Предварительная фильтрация запросов к диску
3. **Сетевые технологии**: Проверка URL в веб-краулерах
4. **Системы безопасности**: Проверка запрещённых паролей или токенов
5. **Блокчейн**: Оптимизация проверки транзакций

## Ссылки

1. [Bloom filter](https://en.wikipedia.org/wiki/Bloom_filter)
2. [Counting Bloom filter](https://en.wikipedia.org/wiki/Counting_Bloom_filter)

## Заключение

Bloom filter предоставляет эффективный компромисс между использованием памяти и вероятностью ошибок.
Для сценариев, где допустимы ложноположительные срабатывания, он может сократить использование памяти в 10-30 раз
по сравнению с традиционными структурами данных.
Реализация с атомарными операциями позволяет эффективно использовать фильтр в многопоточных средах без необходимости
в сложных механизмов синхронизации.
