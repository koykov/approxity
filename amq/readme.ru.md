# AMQ (Approximate Membership Query) Filters

Этот репозиторий содержит реализации вероятностных структур данных (AMQ-фильтров) на Go, разработанные для использования
в highload-условиях.

## Что такое AMQ-фильтры?

Approximate Membership Query (AMQ) структуры - это вероятностные структуры данных, которые позволяют эффективно проверять
принадлежность элемента к множеству. Они решают задачи:

- Фильтрации уже обработанных элементов
- Предварительной проверки кэша
- Уменьшения дорогостоящих запросов к базе данных
- Снижения сетевого трафика в распределённых системах

При этом AMQ-фильтры могут давать ложноположительные срабатывания (но не ложноотрицательные), в обмен на компактное
представление данных.

## Реализованные структуры

- [**Bloom filter**](bloom_filter) - классическая вероятностная структура, использующая несколько хэш-функций для
  установки битов в битовом массиве.
- [**Cuckoo filter**](cuckoo_filter) - улучшенная версия Bloom filter, поддерживающая удаление элементов и имеющая более
  высокую плотность хранения.
- [**Quotient filter**](quotient_filter) - компактная структура, организующая данные в виде хэш-таблицы с особым способом
  разрешения коллизий.
- [**Xor filter**](xor_filter) - одна из самых новых и эффективных структур, обеспечивающая минимальный процент ложных
  срабатываний при компактном хранении.

## Особенности реализации

Все реализации разработаны с учётом требований highload-систем и многопоточной среды:

- Высокая производительность при параллельных чтении/записи
- Минимизация блокировок и contention'а (использование только atomic операций)
- Минимизация аллокации памяти
- Минимально возможное потребление памяти
- Использование SIMD операций (где возможно)

### Инициализация

Каждая пакет содержит структуру `Config`, позволяющую гибко настроить фильтр в зависимости от требования.
Пример [`Config`](bloom_filter/config.go). Общим у всех этих фильтров является возможность задать:

- Нужную хэш-функцию (обязательный параметр)
- Предполагаемое количество элементов для хранения (обязательный параметр)
- Режим поддержки конкурентных операций (отключён по умолчанию)
- Параметр [`MetricsWriter`](metrics.go) для записи метрик

### Сериализация и восстановление

Все структуры поддерживают:
- Сохранение текущего состояния в `io.WriterTo`
- Восстановление состояния из `io.ReaderFrom` (решение проблемы холодного старта)

Комбинация этих возможностей решает проблему холодного старта фильтра - настроив периодическое сохранение фильтра в
хранилище, например в файл или облако, при старте фильтра вы будете иметь сразу готовый к работе фильтр. Если включён
режим поддержки конкурентных операций, то эти операции будут выполняться с защитой от гонок данных.

### Единый интерфейс

Все фильтры реализуют общий интерфейс [`Filter`](interface.go), позволяющий:

- Добавлять элементы в фильтр
- Проверять принадлежность элемента
- Удалять элементов из фильтра (если возможно, например Bloom фильтр это запрещает)
- Получать текущий размер/ёмкость фильтра
- Очищать фильтр

Это позволяет легко заменять одну реализацию другой без изменения кода приложения.

### Мониторинг и метрики

В каждую структуру, через `Config` структуру можно передать реализацию [`MetricsWriter`](metrics.go), которая будет писать
метрики:

- Сколько элементов добавлено в фильтр
- Сколько элементов удалено из фильтра
- Сколько чтений и с каким результатом было выполнено

Этот подход позволит решить проблему "чёрного ящика" - метрики помогут оценить насколько оптимально используется фильтр
и как его можно настроить оптимальнее.

Пакет содержит коробочную реализацию [Prometheus](../metrics/prometheus/amq.go) TSDB, но вы вольны написать вашу
собственную реализацию для нужной TSDB (например VictoriaMetrics).

## Заключение

AMQ-фильтры это мощный инструмент для решения задач фильтрации данных, но использовать их имеет смысл только тогда,
когда более простые подходы (например на базе хэш-таблиц) перестают быть эффективными с точки зрения памяти и/или
производительности.
