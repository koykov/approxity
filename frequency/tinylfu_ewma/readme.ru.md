# TinyLFU + EWMA

TinyLFU (Tiny Least Frequently Used) это вероятностная структура на базе [Count-Min Sketch](../cmsketch), которая
позволяет оценивать частоту появления элементов в потоке данных, но дополнительно способно "забывать" данные о хранимых
элементах - через периодический decay или плавное затухание.

## Использование

Минимальный рабочий пример:

```go
package main

import (
  "time"

  "github.com/koykov/hash/xxhash"
  "github.com/koykov/pbtk/frequency/tinylfu_ewma"
)

const (
  confidence = 0.99999
  epsilon    = 0.00001
)

func main() {
  conf := tinylfu.NewConfig(confidence, epsilon, xxhash.Hasher64[[]byte]{}).
    WithEWMATau(60) // smoothing constant time 1 minute
  est, err := tinylfu.NewEstimator(conf)
  _ = err
  _ = est.AddN("foobar", 5)
  println("time=0", est.Estimate("foobar")) // time=0 +5.000000e+000
  time.Sleep(15 * time.Second)
  println("time=15", est.Estimate("foobar")) // time=15 +3.894004e+000
  time.Sleep(30 * time.Second)
  println("time=45", est.Estimate("foobar")) // time=45 +2.361833e+000
  time.Sleep(15 * time.Second)
  println("time=60", est.Estimate("foobar")) // time=60 +1.839397e+000

  _ = est.AddN("foobar", 30)
  println("time=0 (after update)", est.Estimate("foobar")) // time=0 (after update) +2.000000e+001 (20)
  time.Sleep(15 * time.Second)
  println("time=15 (after update)", est.Estimate("foobar")) // time=15 (after update) +1.557602e+001 (~15.576)
}
```

Как видно из примера, структура подсчитывает частоту элемента "foobar" с затуханием. В следующем разделе будут
рассмотрены теоретические основы работы алгоритма.

Структура [Config](config.go) позволяет настроить TinyLFU более детально (см. описание и комментарии).

## Как это работает

Дла начала следует рассмотреть как работает Count-Min Sketch (далее CMS) структура. CMS также является вероятностной
структурой для решения frequency estimation задачи с заданной точностью $ε$ и достоверностью $δ$. Она представляет собой
матрицу счётчиков шириной $w$ и глубиной $d$. Они вычисляются по формулам:

$$
w = \lceil{e \over ϵ}\rceil
$$
$$
d = \lceil ln({1 \over {1-δ}})\rceil
$$

где $e$ - основание натурального логарифма (~2.718).

Для каждого добавляемого/обновляемого элемента $x$ и его веса $Δ$:

* вычисляется позиция на базе $d$ хэшей

$$
j = {hash_i(x) \bmod w}
$$

* увеличивается счётчик в позиции $i$ и $j$

$$
CMS[i][j] += Δ
$$

Для вычисления частоты $E$ элемента $x$:

* вычисляется минимальное значение всех $d$ счётчиков для элемента $x$

$$
E(x) = \min\limits_{i∈[0,d−1]} CMS[i][hash_i(x) \bmod w]
$$

Проблемой CMS является завышение оценок (из-за коллизий). Классический TinyLFU решает эту проблему с помощью
периодического
decay счётчиков - хранит общий счётчик добавлений/обновлений элементов и, по достижении определённого лимита, умножает
все счётчики на $decay factor$ (как правило $0.5$). Этот способ мне не понравился из-за временной сложности (надо обойти
весь CMS)
и слишком частого использования atomic операций. Поэтому я адаптировал формулу EWMA (экспоненциальное взвешенное
скользящее среднее)
как более элегантный способ решения проблемы - он позволяет обойтись как без обхода всего CMS, так и решает проблему с
излишними блокировками. Выглядит формула так:

$$
freq = counter * e^{-{Δt \over τ}} + Δ * (1 - e^{-{Δt \over τ}})
$$

где:

* $e$ - основание натурального логарифма (~2.718)
* $Δt$ - время с последнего момента обновления элемента
* $τ$ (tau) - константа времени затухания (как правило 1 секунда, но это можно настраивать)
* $counter$ - текущее значение счётчика в CMS
* $Δ$ - вес обновляемого элемента

> [!NOTE]
> Эта же формула используется для вычисления load average в Linux.

Так как для работы одного счётчика становится необходимым хранить как само значение счётчика, так и момент времени
последнего обновления, сам счётчик стал композитным. Теперь это 64-битное беззнаковое число, где в первых 32-х битах
хранится время с момента старта TinyLFU (для компактности - если работать с секундами, то это позволяет храниться 2^32
секунд, что составляет ~136 лет), а во вторых 32-х битах само значение счётчика. Ограничение в 32 бита на счётчик
ограничивает его значением 4294967295, так что учитывайте его при проектировании своей системы.

К чему такие сложности? Во-первых, это позволяет работать с счётчиком атомарно в конкуррентной среде, во-вторых, это
экономит память. Это также добавляет небольшой оверхед для применения EWMA - перед вычислением необходимо значение
счётчика разделить на два 32-хбитных значения, а после вычисления слепить из двух 32-хбитных значений (новое время
обновления и вычисленное значение счётчика) одно 64-битное значение.

В итоге, для вычисления частоты достаточно применить формулу

$$
Δt, counter = decode(CMS[i][hash_i(x) \bmod w])
$$

$$
E(x) = \min\limits_{i∈[0,d−1]} counter * e^{-{Δt \over τ}}
$$

Таким образом, проблема оказывается решённой посредством математических преобразований и нет нужды выполнять тяжёлый
decay счётчиков.

## Ссылки

Учитывайте, что тут приведены ссылки на классический TinyLFU (с периодическим decay счётчиков). Эта версия использует
EWMA сглаживание (см раздел выше), а классический вариант реализации приведён для примера.

* https://florian.github.io/count-min-sketch/ описание Count-Min Sketch и интерактивный пример
* https://arxiv.org/abs/1512.00727 описание TinyLFU
* https://highscalability.com/design-of-a-modern-cache/ ещё одно описание TinyLFU
* https://towardsdatascience.com/time-series-from-scratch-exponentially-weighted-moving-averages-ewma-theory-and-implementation-607661d574fe/
  EWMA: теория
* https://www.brendangregg.com/blog/2017-08-08/linux-load-averages.html EWMA: Linux load average
* https://observablehq.com/@stwind/exponentially-weighted-moving-average EWMA: интерактивный калькулятор
