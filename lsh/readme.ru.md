# LSH (Locality-Sensitive Hashing)

Locality-Sensitive Hashing (LSH) - это метод приближенного поиска ближайших соседей, который хэширует входные данные
таким образом, чтобы похожие объекты с высокой вероятностью попадали в один и тот же "бакет". LSH решает задачи:
* Поиска дубликатов
* Кластеризации похожих документов
* Рекомендательных систем
* Обнаружения плагиата

## Реализованные алгоритмы

* **SimHash** - Генерирует fingerprint документа, где похожие документы имеют небольшое расстояние Хэмминга между своими хэшами.
  Особенно эффективен для обнаружения почти дублирующегося контента.
* **MinHash** - Оценивает схожесть множеств на основе вероятности совпадения минимальных хэшей. Оптимален для сравнения
  наборов данных (например, наборов слов в документах).
* **B-Bit MinHash** - Оптимизированная версия MinHash, которая использует только младшие биты каждого хэша, что значительно
  сокращает объем хранимых данных при сохранении приемлемой точности.

Реализованные алгоритмы предназначены для обработки только текстовых данных.

## Особенности реализации

* **Высокая производительность**: Минимизированы аллокации памяти, использованы эффективные структуры данных
* **Единый интерфейс**: Все алгоритмы реализуют интерфейс [`Hasher`](interface.go), что позволяет легко заменять один алгоритм другим
* **Гибкость**: Поддержка различных shingler'ов для преобразования текста в шинглы и различных алгоритмов хэширования шинглов
* **Масштабируемость**: Оптимизировано для работы с большими объемами данных

## Использование

```go
package main

import (
	"fmt"

	"github.com/koykov/hash/xxhash"
	"github.com/koykov/pbtk/lsh/minhash"
	"github.com/koykov/pbtk/shingle"
)

const k = 50 // number of hash functions

func main() {
	hasher := xxhash.Hasher64[[]byte]{}
	shingler := shingle.NewChar[[]byte](3, "") // 3-gram char shingler
	h, err := minhash.NewHasher[[]byte](minhash.NewConfig(hasher, k, shingler))
	_ = err
	_ = h.Add([]byte("A person in a black jacket is doing tricks on a motorbike"))
	fmt.Printf("%#v\n", h.Hash()) // []uint64{0xdb9aae3abdd1a77, 0x46b42729237c368, ..., 0x3f710684c9bab1f}

	h.Reset()
	_ = h.Add([]byte("Two men are taking a break from a trip on a snowy road"))
	fmt.Printf("%#v\n", h.Hash()) // []uint64{0x3e2eaf1df906ab, 0x4a12c40f3825533, ..., 0x5505351f1a39fa3}
}
```

## Примеры применения

1. **Поиск дубликатов документов** в больших корпусах текстов
2. **Рекомендательные системы** для поиска похожего контента
3. **Обнаружение плагиата** в академических работах или исходном коде
4. **Кластеризация новостей** для группировки схожих сообщений из разных источников
5. **Поиск похожих пользователей** по их активности или предпочтениям

## Заключение

Эта библиотека предоставляет эффективные реализации популярных LSH-алгоритмов, готовые к работе в highload окружениях.
Благодаря единому интерфейсу и оптимизациям производительности, она может быть легко интегрирована в существующие системы
для решения задач поиска схожих объектов.
Выбор конкретного алгоритма зависит от особенностей данных и требований к точности оценки схожести.
